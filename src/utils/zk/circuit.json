{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 11106019120628044212,
  "abi": {
    "parameters": [
      {
        "name": "signer_pub_x_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signer_pub_y_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "selected_players_points",
        "type": {
          "kind": "array",
          "length": 11,
          "type": {
            "kind": "array",
            "length": 32,
            "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
          }
        },
        "visibility": "private"
      },
      {
        "name": "player_points_merkle_paths",
        "type": {
          "kind": "array",
          "length": 11,
          "type": {
            "kind": "array",
            "length": 6,
            "type": {
              "kind": "array",
              "length": 32,
              "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
            }
          }
        },
        "visibility": "private"
      },
      {
        "name": "all_player_points_merkle_root",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "selected_player_ids",
        "type": {
          "kind": "array",
          "length": 11,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "selected_squad_hash",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "claimed_player_points",
        "type": { "kind": "integer", "sign": "unsigned", "width": 64 },
        "visibility": "public"
      }
    ],
    "param_witnesses": {
      "all_player_points_merkle_root": [{ "start": 2592, "end": 2624 }],
      "claimed_player_points": [{ "start": 2667, "end": 2668 }],
      "player_points_merkle_paths": [{ "start": 480, "end": 2592 }],
      "selected_player_ids": [{ "start": 2624, "end": 2635 }],
      "selected_players_points": [{ "start": 128, "end": 480 }],
      "selected_squad_hash": [{ "start": 2635, "end": 2667 }],
      "signature": [{ "start": 64, "end": 128 }],
      "signer_pub_x_key": [{ "start": 0, "end": 32 }],
      "signer_pub_y_key": [{ "start": 32, "end": 64 }]
    },
    "return_type": null,
    "return_witnesses": []
  },
  "bytecode": "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",
  "debug_symbols": "zdzdjl5Feobhc/E2ir73Z1XVy6lE2UDJRBppxESBPeRzD25stzN0j5vLWiP2EOrH9dG6C9QXq9cv7/729//84ee//v3Hn959/8u7XOu8+/7ff3n30//88OOHv/HTzz/878/vvu/u79795cf/evf9tc77797991//9pdf/269/+53Xxpd+fFr48r8yhfn+fzF1fP8xdf7//juw6eZf+mnqfP49MUd9btPsx9/qk8T3/pprrM+HbCu+edfnNf18Wtz1vOX9kt/buSnzxD50gfPP8UH/+2z1L/ys1R8+nOr+ivfxK/cjN1/1g/+tWyvb/3g+8SnA06sL7/4twPW3Qfsuw84dx8wNx9wHncfEHcfkHcfUHcf0HcfcPdNPnff5HP3TT533+Rz902eu2/y3H2T5+6bPHff5Ln7Js/dN3nuvslz902eu2/y3HyT9+Nx9wFx9wF59wF19wF99wHX3Qesuw/Ydx9w7j7g7pscd9/kuPsmx903Ob75Jq/1+cfj/eWPsZ8O+PabHPP5gP//xb8d8OJNvvYnzVhf/iD+4gG//rHPDJO/P2DdfcD+1gMyr88HXC98i87dB8zNB+Tj7gPi7gPy7gPq7gP67gOuuw9Ydx9w903Ou29y3n2T6+6bXHff5Lr7JtfdN7nuvsl1902uu29y3X2T6+6bXHff5L77JvfdN7nvvsl9903uu29y332T++6b3Hff5L77JveLN3mu83E08/uf664HbAI2CZuCTcPmgs2CzYbNgQ10sKCDBR0s6GBBBws6WNDBgg4WdLCggwUdbOhgQwcbOtjQwYYONnSwoYMNHWzoYEMHBzo40MGBDg50cKCDAx0c6OBABwc6ONDBQAcDHQx0MNDBQAcDHQx0MNDBQAfzxzs4jwdsAjYJm4JNw+aCzYLNhs2BDXQQ0EFABwEdBHQQ0EFABwEdBHQQ0EFABwkdJHSQ0EFCBwkdJHSQ0EFCBwkdJHRQ0EFBBwUdFHRQ0EFBBwUdFHRQ0EFBBw0dNHTQ0EFDBw0dNHTQ0EFDBw0dgCce8MQDnnjAEw944gFPPOCJBzzxgCce8MQDnnjAEw944gFPPOCJBzzxgCce8MQDnnjAEw944gFPPOCJBzzxgCce8MQDnnjAEw944gFPPOCJBzzxgCce8MQDnnjAEw944gFPPOCJBzzxgCce8MQDnnjAEw944gFPPOCJBzzxgCce8MQDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJA5444IkDnjjgiQOeOOCJ88c9sR5/3BN/3QRsEjYFm4bNBZsFmw2bAxvoIKCDgA4COgjoIKCDgA4COgjoIKCDgA4SOkjoIKGDhA4SOkjoIKGDhA4SOkjooKCDgg4KOijooKCDgg4KOijooKCDgg4aOmjooKGDhg4aOmjooKGDhg4aOmjo4IIOLujggg4u6OCCDi7o4IIOLujggg4u6GBBBws6WNDBgg4WdLCggwUdLOhgQQcLOtjQwYYONnSwoYMNHWzoYEMHGzrY0MGGDg50cKCDAx0c6OBABwc6ONDBgQ4OdHCgg4EOBjoY6GCgg4EOBjoY6GCgg4EOwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATAzwxwBMDPDHAEwM8McATEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBExM8McETEzwxwRMTPDHBEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMLPLHAEws8scATCzyxwBMbPLHBExs8scETGzyxwRMbPLHBExs8scETGzyxwRMbPLHBExs8scETGzyxwRMbPLHBExs8scETGzyxwRMbPLHBExs8scETGzyxwRMbPLHBExs8scETGzyxwRMbPLHBExs8scETGzyxwRMbPLHBExs8scETGzyxwRMbPLFf9sR45Po4isfuf1jlWuffXv4Pca7eH4e//uV5Hq7nYevw0uHS4dbh0eHg8OX/Vr9lGDpMHWo5qeWklpNaTmo5qeWkllNaTmk5peWUllNaTmk5peWUllNaTmk5reW0ltNaTms5reW0ltNaTms5reW0lnNpOZeWc2k5l5ZzaTmXlnNpOZeWc2k5l5aztJyl5SwtZ2k5S8tZWs7ScpaWs7ScpeVsLWdrOVvL2VrO1nK2lrO1nK3lbC1nazlHyzlaztFyjpZztJyj5Rwt52g5R8s5Ws5oOaPljJYzWs5oOaPljJYzWs5oOaPlvPLy6Tctg5fJS9bAB3Pggz3wwSD4YBF8MAk+uKHghoIbCm7IRdlJ2U3ZUdlV2VmZXTkYloNlOZiWg205GJeDdTmYl4N9ORiYg4U5mJiDjTkYmYOVOZiZg505GJqDpTmYmoOtORibg7U5mJuj/f+OckMszsHkHGzOwegcrM7B7BzszsHwHCzPwfQcbM/B+Bysz8H8HOzPwQAdLNDBBB1s0MEIHcuf0+CG2KGDITpYooMpOtiigzE6WKODOTrYo2P7wz7cEJN0sEkHo3Sw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",
  "file_map": {
    "25": {
      "source": "mod hash;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod grumpkin_scalar;\nmod grumpkin_scalar_mul;\nmod scalar_mul;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(_with_newline: bool, _input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(_verification_key: [Field], _proof: [Field], _public_inputs: [Field], _key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(_x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(_x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(_x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n",
      "path": "std/lib.nr"
    },
    "43": {
      "source": "mod tests;\nuse dep::std;\nuse dep::ecrecover;\n\nglobal MERKLE_DEPTH = 6;\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    selected_players_points: [[u8; 32]; 11],\n    player_points_merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    all_player_points_merkle_root: [u8; 32],\n    selected_player_ids: pub [u8; 11],\n    selected_squad_hash: pub [u8; 32],\n    claimed_player_points: pub u64\n) {\n    ecdsa_verification(\n        signer_pub_x_key,\n        signer_pub_y_key,\n        signature,\n        selected_squad_hash\n    );\n\n    verify_squad_hash(selected_player_ids, selected_squad_hash);\n\n    // verify_all_merkle_roots(\n    //     selected_player_ids,\n    //     selected_players_points,\n    //     player_points_merkle_paths,\n    //     all_player_points_merkle_root\n    // );\n\n    let mut calculated_total_points: u64 = 0;\n\n    for point in selected_players_points {\n        for byte in point {\n            calculated_total_points += byte as u64;\n        }\n    }\n\n    assert(calculated_total_points == claimed_player_points);\n}\n\nfn verify_squad_hash(player_ids: [u8; 11], squad_hash: [u8; 32]) {\n    let computed_squad_hash= std::hash::keccak256(player_ids, 11);\n    assert(computed_squad_hash == squad_hash);\n}\n\nfn ecdsa_verification(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    hash: [u8; 32]\n) {\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address(); // Compute address from public key\n    let recoveredAddress = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, hash);\n\n    println(f\"Computed address: {computedAddress}\");\n    println(f\"Recovered address: {recoveredAddress}\");\n    assert(computedAddress == recoveredAddress);\n}\n\nfn verify_all_merkle_roots(\n    player_ids: [u8; 11],\n    players_points: [[u8; 32]; 11],\n    merkle_paths: [[[u8; 32]; MERKLE_DEPTH]; 11],\n    merkle_root: [u8; 32]\n) {\n    for i in 0..11 {\n        compute_and_verify_merkle_root(players_points[i], player_ids[i], merkle_paths[i], merkle_root);\n    }\n}\n\nfn compute_and_verify_merkle_root(\n    leaf: [u8; 32],\n    leaf_index: u8,\n    proof: [[u8; 32]; MERKLE_DEPTH],\n    all_points_merkle_root: [u8; 32]\n) {\n    let mut computed_merkle_root: [u8; 32] = [0; 32];\n    computed_merkle_root=leaf;\n    let mut leaf_index_mut= leaf_index;\n    for i in 0..MERKLE_DEPTH {\n        if leaf_index_mut % 2 == 0 {\n            computed_merkle_root = std::hash::keccak256(concatenate_leafs(computed_merkle_root, proof[i]), 64);\n        } else {\n            computed_merkle_root = std::hash::keccak256(concatenate_leafs(proof[i], computed_merkle_root), 64);\n        }\n        leaf_index_mut = leaf_index_mut / 2;\n    }\n\n    println(f\"Computed merkle root: {computed_merkle_root}\");\n    println(f\"All points merkle root: {all_points_merkle_root}\");\n    assert(computed_merkle_root == all_points_merkle_root);\n}\n\nfn concatenate_leafs(leaf1: [u8; 32], leaf2: [u8; 32]) -> [u8; 64] {\n    let mut arr: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        arr[i] = leaf1[i];\n        arr[i + 32] = leaf2[i];\n    }\n    arr\n}\n",
      "path": "/Users/gabrielantonyxaviour/Developer/projects/luffy/circuits/src/main.nr"
    },
    "44": {
      "source": "use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"
    },
    "45": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"
    },
    "46": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"
    }
  }
}
